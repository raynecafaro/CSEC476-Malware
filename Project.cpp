// Project.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <winsock2.h>
#include <iphlpapi.h>
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <VersionHelpers.h>
#include <psapi.h>
#pragma comment(lib, "IPHLPAPI.lib")
#pragma warning(disable : 4996)

static const unsigned char base64_table[65] =
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static const unsigned char custom_table[65] =
"uLoqK3h57MieJNUPzmdG1A9DCZBtjwlOVWaYTcx2pI/g0rb+4SfE6nFRHvyXkQs8";

#define INFO_BUFFER_SIZE 32767

//Encodes with base64
char* base64_encode(const unsigned char *src, size_t len){
	unsigned char *out, *pos;
	const unsigned char *end, *in;

	char outStr[INFO_BUFFER_SIZE] = {0};

	out = (unsigned char*)&outStr[0];

	end = src + len;
	in = src;
	pos = out;
	while (end - in >= 3) {
		*pos++ = base64_table[in[0] >> 2];
		*pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
		*pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
		*pos++ = base64_table[in[2] & 0x3f];
		in += 3;
	}

	if (end - in) {
		*pos++ = base64_table[in[0] >> 2];
		if (end - in == 1) {
			*pos++ = base64_table[(in[0] & 0x03) << 4];
			*pos++ = '=';
		}
		else {
			*pos++ = base64_table[((in[0] & 0x03) << 4) |
				(in[1] >> 4)];
			*pos++ = base64_table[(in[1] & 0x0f) << 2];
		}
		*pos++ = '=';
	}
	return outStr;
}

//Gets the Name of a Process from the ID
char* GetProcessName(DWORD processID){
	TCHAR szProcessName[INFO_BUFFER_SIZE] = TEXT("Unknown Process Name");;

	HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
		PROCESS_VM_READ,
		FALSE, processID);

	if (NULL != hProcess){
		HMODULE hMod;
		DWORD cbNeeded;

		if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)){
			GetModuleBaseName(hProcess, hMod, szProcessName,
				sizeof(szProcessName) / sizeof(TCHAR));
		}
	}

	CloseHandle(hProcess);

	char* ProcessName = (char*)malloc(INFO_BUFFER_SIZE);
	wcstombs(ProcessName, szProcessName, wcslen(szProcessName) + 1);
	return ProcessName;
}

// Gets IP if arg is True
// Get MAC if arg is False
char* getIpOrMac(bool ip) {
	PIP_ADAPTER_INFO AdapterInfo;
	DWORD dwBufLen = sizeof(AdapterInfo);
	char *mac_addr = (char*)malloc(17);

	AdapterInfo = (IP_ADAPTER_INFO *)malloc(sizeof(IP_ADAPTER_INFO));
	if (AdapterInfo == NULL) {
		printf("Error allocating memory needed to call GetAdaptersinfo\n");

	}

	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {

		AdapterInfo = (IP_ADAPTER_INFO *)malloc(dwBufLen);
		if (AdapterInfo == NULL) {
			printf("Error allocating memory needed to call GetAdaptersinfo\n");
		}
	}

	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) {
		PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo; // Contains pointer to current adapter info

		sprintf(mac_addr, "%02X:%02X:%02X:%02X:%02X:%02X",
			pAdapterInfo->Address[0], pAdapterInfo->Address[1],
			pAdapterInfo->Address[2], pAdapterInfo->Address[3],
			pAdapterInfo->Address[4], pAdapterInfo->Address[5]);

		if (ip) {
			char* ipaddr = pAdapterInfo->IpAddressList.IpAddress.String;
			return ipaddr;
		} else {
			free(AdapterInfo);
			return mac_addr;
		}
		free(AdapterInfo);
	}
	free(AdapterInfo);
}

//Gets the Operating System
const char* getOperatingSystem() {

	if (IsWindows10OrGreater()){
		return "Windows 10 Or Greater\0";
	}

	if (IsWindows8Point1OrGreater()){
		return "Windows 8.1O or Greater\0";
	}

	if (IsWindows8OrGreater()){
		return "Windows 8 Or Greater\0";
	}

	if (IsWindows7OrGreater()) {
		return "Windows 7 Or Greater\0";
	}

	if (IsWindowsVistaOrGreater()) {
		return "Vista Or Greater\0";
	}

	if (IsWindowsXPOrGreater()) {
		return "XP Or Greater\0";
	}
	else {
		return "Unknown Version\0";
	}
}

int __cdecl main(){

	char command[] = "PROCESSES";

	if (!strcmp(command, "MAC ADDRESS")){
		char* mac = getIpOrMac(false);
		char* base64_mac = base64_encode((const unsigned char*)mac, strlen(mac));
		printf("%s, %s\n", mac, base64_mac);
	}
	else if (!strcmp(command, "IP ADDRESS")) {
		char* ip = getIpOrMac(true);
		char* base64_ip = base64_encode((const unsigned char*)ip, strlen(ip));
		printf("%s, %s\n", ip, base64_ip);
	}
	else if (!strcmp(command, "USERNAME")) {
		TCHAR  infoBuf[INFO_BUFFER_SIZE];
		DWORD  bufCharCount = INFO_BUFFER_SIZE;

		if (!GetUserName(infoBuf, &bufCharCount)) {
			printf("Error with GetUserName");
		}

		char username[INFO_BUFFER_SIZE];

		//convert TCHAR to char*
		wcstombs(username, infoBuf, wcslen(infoBuf) + 1);

		char* base64_username = base64_encode((const unsigned char*)username, strlen(username));
		printf("%s, %s\n", username, base64_username);
	}
	else if (!strcmp(command, "OS")) {
		const char* operatingSys = getOperatingSystem();
		char* base64_operatingSys = base64_encode((const unsigned char*)operatingSys, strlen(operatingSys));
		printf("%s, %s\n", operatingSys, base64_operatingSys);
	}
	else if (!strcmp(command, "PROCESSES")) {
		DWORD aProcesses[1024], cbNeeded, cProcesses;
		unsigned int x;

		if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded)) {
			return 1;
		}

		cProcesses = cbNeeded / sizeof(DWORD);

		for (x = 0; x < cProcesses; x++) {
			if (aProcesses[x] != 0) {
				char* ProcName = GetProcessName(aProcesses[x]);
				char wholeString[100];
				sprintf(wholeString, "PID: %d, Name: %s", aProcesses[x], ProcName);
				char* base64_ProcName = base64_encode((const unsigned char*)wholeString, strlen(wholeString));
				printf("PID: %d, Name: %s\n", aProcesses[x], ProcName);
				printf("%s\n", base64_ProcName);
				free(ProcName);
			}
		}
	}
	else if (!strcmp(command, "UPLOAD")) {
		FILE *fp;
		long lSize;
		size_t result;

		fp = fopen("upload.txt", "w");

		char* buffer = (char*)malloc(10);
		strcpy(buffer, "1234567890");
		printf("%d\n", strlen(buffer));
		fwrite(buffer, strlen(buffer), 1, fp);
		fclose(fp);
	}
	else if (!strcmp(command, "DOWNLOAD")) {
		FILE *fp;
		long lSize;
		char * buffer;
		size_t result;

		fp = fopen("download.txt", "rb");
		fseek(fp, 0, SEEK_END);
		lSize = ftell(fp);
		rewind(fp);
		buffer = (char*)malloc(lSize + 1);
		fread(buffer, lSize, 1, fp);
		fclose(fp);
		buffer[lSize] = '\0';
		printf("%s\n", buffer);
		free(buffer);
		return 0;
	}
	return 1;
}
